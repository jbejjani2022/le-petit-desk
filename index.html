<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-MDXNW9DF26"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-MDXNW9DF26');
  </script>

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>le petit desk</title>
  <link rel="icon" type="image/png" href="static/turtle_base/sprite_0.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300&family=Space+Grotesk:wght@300&family=Inter:wght@300&family=Poppins:wght@200&family=Epilogue:wght@200&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
  <style>
    :root {
      --bg: #3c2626;
      --text: #fdf6ec;
      --accent: #df7829;
      --font-family: 'Outfit', sans-serif;
    }

    body {
      margin: 0;
      font-family: var(--font-family);
      font-weight: 300;
      background: var(--bg);
      color: var(--text);
      overflow-x: hidden;
    }

    section {
      min-height: 50vh;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 3rem 2rem;
    }

    section.landing {
      min-height: 85vh;
      position: relative;
      /* Crucial for turtle containment */
      overflow: hidden;
    }

    .landing-container {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .desk-graphic {
      display: block;
      margin: 0 auto;
      max-width: 100%;
      height: auto;
    }

    section.subscribe {
      min-height: 60vh;
      align-items: center;
      justify-content: center;
      padding-bottom: 0rem;
    }

    .subscribe form {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1rem;
    }

    h1, h2, h3, p {
      margin: 0.5rem 0;
    }

    h1 {
      font-size: 3.5rem;
    }

    h2 {
      font-size: 2.2rem;
    }

    p {
      font-size: 1.6rem;
      line-height: 1.6;
    }

    h1.title {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      margin: 0;
      pointer-events: none;
    }

    h1.title span {
      position: absolute;
      display: inline-block;
      opacity: 0;
      transform: translateY(-400px);
      transform-origin: center center;
      font-weight: bold;
      font-size: clamp(1.6rem, 3.5vw, 3.5rem); /* min, preferred, max */
    }

    .mission, .upcoming, .past, .subscribe {
      opacity: 0;
      transform: translateY(100px);
      will-change: transform, opacity;
    }

    .mission p {
      opacity: 0;
      transform: translateY(80px);
      will-change: transform, opacity;
    }

    .subscribe form {
      opacity: 0;
      transform: translateY(80px);
      will-change: transform, opacity;
    }

    .event {
      margin: 1rem 0;
      font-size: 1.7rem;
      opacity: 0;
      transform: translateY(60px);
      will-change: transform, opacity;
    }

    .event.upcoming-title, .event.past-title, .event.mission-title {
      color: var(--accent);
      font-weight: bold;
      font-size: 2.2rem;
      margin-bottom: 2rem;
    }

    input[type="email"] {
      background: transparent;
      border: none;
      border-bottom: 2px solid var(--text);
      color: var(--text);
      font-family: var(--font-family);
      font-weight: 300;
      font-size: 1.3rem;
      text-align: center;
      outline: none;
      padding: 1rem;
      width: 350px;
      transition: border-bottom-color 0.3s ease;
      border-radius: 0;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      box-shadow: none;
      background-clip: padding-box;
      caret-color: var(--text);
    }

    input[type="email"]:focus {
      border-bottom-color: var(--accent);
      box-shadow: none;
    }

    input[type="email"]::placeholder {
      color: rgba(253, 246, 236, 0.5);
    }

    input[type="email"]:-webkit-autofill {
      -webkit-box-shadow: 0 0 0px 1000px transparent inset;
      box-shadow: 0 0 0px 1000px transparent inset;
      -webkit-text-fill-color: var(--text);
      border-bottom-color: var(--text);
      transition: background-color 5000s ease-in-out 0s;
    }
    input[type="email"]:-webkit-autofill:focus {
      border-bottom-color: var(--accent);
      -webkit-text-fill-color: var(--text);
    }

    .subscribe-text {
      font-size: 1.2rem;
      margin-top: 1rem;
      color: rgba(253, 246, 236, 0.7);
    }

    .error-message {
      color: #ff6b6b;
      font-size: 1rem;
      margin-top: 0.5rem;
      opacity: 0;
      transition: opacity 0.3s ease;
      font-family: var(--font-family);
      font-weight: 300;
    }

    .error-message.show {
      opacity: 1;
    }

    .jam-with-us {
      font-size: 1.2rem;
      margin-top: 2rem;
      color: rgba(253, 246, 236, 0.7);
      font-family: var(--font-family);
      font-weight: 300;
    }

    .jam-with-us a {
      color: var(--text);
      text-decoration: none;
      transition: color 0.3s ease;
    }

    .jam-with-us a:hover {
      color: var(--accent);
    }

    .instagram-icon {
      position: fixed;
      top: 2rem;
      left: 2rem;
      z-index: 100;
      width: 28px;
      height: 28px;
      fill: var(--text);
      transition: fill 0.3s ease, transform 0.2s ease;
      cursor: pointer;
    }

    .instagram-icon:hover {
      fill: var(--accent);
      transform: scale(1.1);
    }

    .dot-nav {
      position: fixed;
      right: 2rem;
      top: 50%;
      transform: translateY(-50%) scale(0.85);
      transform-origin: right center;
      z-index: 100;
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
      transition: transform 0.25s ease, opacity 0.25s ease;
      opacity: 0.7;
    }

    .dot-nav.expanded {
      transform: translateY(-50%) scale(1.1);
      opacity: 1;
    }

    .dot-nav .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: rgba(253, 246, 236, 0.3);
      border: 2px solid rgba(253, 246, 236, 0.5);
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      outline: none;
      -webkit-tap-highlight-color: transparent;
    }

    .dot-nav .dot:focus,
    .dot-nav .dot:focus-visible,
    .dot-nav .dot:active {
      outline: none;
      box-shadow: none;
    }

    .dot-nav .dot::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--accent);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .dot-nav .dot.active {
      background: rgba(233, 164, 111, 0.2);
      border-color: var(--accent);
      transform: scale(1.7);
    }

    .dot-nav .dot.active:hover {
      transform: scale(1.7);
    }

    .dot-nav .dot.active::before {
      opacity: 1;
    }

    .dot-nav .dot:hover {
      background: rgba(253, 246, 236, 0.4);
      border-color: var(--accent);
      transform: scale(1.35);
    }
    
    @media (hover: none) {
      .dot-nav .dot:hover {
        background: rgba(253, 246, 236, 0.3);
        border-color: rgba(253, 246, 236, 0.5);
        transform: none;
      }
      .dot-nav .dot.active,
      .dot-nav .dot.active:hover {
        background: rgba(233, 164, 111, 0.2);
        border-color: var(--accent);
        transform: scale(1.7);
      }
    }

    .event.upcoming-title, .event.past-title, .event.mission-title {
      color: var(--accent) !important;
    }

    :root {
      --content-max: 1000px;
      --rail-safe-space: 6rem;
    }

    section:not(.landing) > div {
      width: min(var(--content-max), calc(100vw - var(--rail-safe-space)));
      margin: 0 auto;
      padding-left: clamp(1rem, 3vw, 2rem);
      padding-right: clamp(1rem, 3vw, 2rem);
    }

    section.subscribe form {
      width: min(var(--content-max), calc(100vw - var(--rail-safe-space)));
      margin: 0 auto;
      padding-left: clamp(1rem, 3vw, 2rem);
      padding-right: clamp(1rem, 3vw, 2rem);
    }

    .footer {
      background: #281c1c;
      color: var(--text);
      text-align: center;
      padding: 2rem 0 1.1rem;
      margin-top: 4rem;
    }

    .footer > div {
      width: min(var(--content-max), calc(100vw - var(--rail-safe-space)));
      margin: 0 auto;
      padding-left: clamp(1rem, 3vw, 2rem);
      padding-right: clamp(1rem, 3vw, 2rem);
    }

    .footer-title {
      font-size: 1.6rem;
      font-weight: bold;
      margin-bottom: 0.5rem;
    }

    .footer-subtitle {
      font-size: 1.1rem;
      color: rgba(253, 246, 236, 0.9);
    }

    .footer a {
      color: var(--text);
      text-decoration: none;
      border-bottom: 1px solid rgba(253, 246, 236, 0.35);
      transition: color 0.3s ease, border-bottom-color 0.3s ease;
    }

    .footer a:hover {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }

    .footer-turtle {
      display: block;
      margin: 0.9rem auto 0;
      width: 52px;
      height: 52px;
    }

    .turtle-container {
      position: relative;
      width: 100%;
      height: 110px;
      margin-top: 2rem;
      overflow: hidden;
    }

    .turtle {
      position: absolute;
      width: 90px;
      height: 90px;
      background-image: url('static/turtle_base/sprite_0.png');
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      top: 10px;
      opacity: 0;
      left: -60px;
    }

    .turtle.animate {
      animation: walkAcrossWithDelay 30s linear infinite, walkSpriteBase 1.4s steps(2) infinite;
    }

    @keyframes walkAcrossWithDelay {
      0% { left: -60px; opacity: 0; }
      5% { left: -60px; opacity: 0; }
      8% { left: -60px; opacity: 1; }
      85% { left: calc(100% + 60px); opacity: 1; }
      88% { left: calc(100% + 60px); opacity: 0; }
      100% { left: calc(100% + 60px); opacity: 0; }
    }

    @keyframes walkSpriteBase {
      0%     { background-image: url('static/turtle_base/sprite_0.png'); }
      49.99% { background-image: url('static/turtle_base/sprite_0.png'); } /* Hold frame 1 */
      50%    { background-image: url('static/turtle_base/sprite_1.png'); } /* Snap to frame 2 */
      100%   { background-image: url('static/turtle_base/sprite_1.png'); } /* Hold frame 2 */
    }

    .concert-turtle {
      position: absolute;
      top: 0;
      left: 0;
      width: 90px;
      height: 90px;
      will-change: transform;
      z-index: 5;
    }

    .turtle-name {
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      color: var(--text);
      font-size: 14px;
      white-space: nowrap;
      font-weight: 500;
      text-shadow: 1px 1px 2px rgba(60, 38, 38, 0.8);
      pointer-events: none;
    }

    .turtle-sprite {
      width: 100%;
      height: 100%;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
    }

    .turtle-0 .turtle-sprite {
      animation: walkSprite0 1.4s steps(2) infinite;
    }

    .turtle-1 .turtle-sprite {
      animation: walkSprite1 1.4s steps(2) infinite;
    }

    .turtle-2 .turtle-sprite {
      animation: walkSprite2 1.4s steps(2) infinite;
    }
    
    @keyframes walkSprite0 {
      0%     { background-image: url('static/turtles_to_spawn/turtle_0/sprite_0.png'); }
      49.99% { background-image: url('static/turtles_to_spawn/turtle_0/sprite_0.png'); } /* Hold frame 1 */
      50%    { background-image: url('static/turtles_to_spawn/turtle_0/sprite_1.png'); } /* Snap to frame 2 */
      100%   { background-image: url('static/turtles_to_spawn/turtle_0/sprite_1.png'); } /* Hold frame 2 */
    }
    
    @keyframes walkSprite1 {
      0%     { background-image: url('static/turtles_to_spawn/turtle_1/sprite_0.png'); }
      49.99% { background-image: url('static/turtles_to_spawn/turtle_1/sprite_0.png'); }
      50%    { background-image: url('static/turtles_to_spawn/turtle_1/sprite_1.png'); }
      100%   { background-image: url('static/turtles_to_spawn/turtle_1/sprite_1.png'); }
    }
    
    @keyframes walkSprite2 {
      0%     { background-image: url('static/turtles_to_spawn/turtle_2/sprite_0.png'); }
      49.99% { background-image: url('static/turtles_to_spawn/turtle_2/sprite_0.png'); }
      50%    { background-image: url('static/turtles_to_spawn/turtle_2/sprite_1.png'); }
      100%   { background-image: url('static/turtles_to_spawn/turtle_2/sprite_1.png'); }
    }

    @media (max-width: 768px) {
      :root { --rail-safe-space: 4.5rem; }
      
      .instagram-icon { top: 1.5rem; left: 1.5rem; width: 28px; height: 28px; }
      .dot-nav { transform: translateY(-50%) scale(0.75); right: 1rem; gap: 1rem; opacity: 0.85; }
      .dot-nav .dot { width: 9px; height: 9px; }
      .dot-nav .dot.active { transform: scale(1.8); }
      
      h1 { font-size: 2.2rem; }
      h2 { font-size: 1.6rem; }
      p { font-size: 1.2rem; }
      .event { font-size: 1.3rem; }
      .event.upcoming-title, .event.past-title, .event.mission-title { font-size: 1.7rem; }
      input[type="email"] { width: 280px; max-width: 72vw; font-size: 1.5rem; }
      .jam-with-us { font-size: 1.1rem; margin-top: 1.5rem; }
      section { padding: 2rem 1rem; min-height: 45vh; }

      section.landing { min-height: 100dvh; display: flex; align-items: center; justify-content: center; width: 100%; max-width: 100%; }
      .landing-container { display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; max-width: 100%; }
      .desk-graphic { width: 150%; max-width: none; height: auto; position: relative; left: 50%; transform: translateX(-50%); display: block; object-fit: contain; object-position: center; }
      section.subscribe { min-height: 60vh; }

      .turtle-container { height: 95px; margin-top: 1.5rem; }
      .turtle { width: 72px; height: 72px; }
      .turtle.animate { animation: walkAcrossWithDelay 24s linear infinite, walkSpriteBase 1.4s steps(2) infinite; }
    }

    @media (max-width: 480px) {
      :root { --rail-safe-space: 4rem; }
      
      .instagram-icon { top: 1rem; left: 1rem; width: 24px; height: 24px; }
      h1 { font-size: 1.8rem; }
      .event.upcoming-title, .event.past-title, .event.mission-title { font-size: 1.4rem; }
      input[type="email"] { width: 240px; max-width: 70vw; font-size: 1.2rem; }
      .jam-with-us { font-size: 1.1rem; margin-top: 1.2rem; }
      section { min-height: 40vh; padding: 1rem 0; }

      section.landing { min-height: 100dvh; display: flex; align-items: center; justify-content: center; width: 100%; max-width: 100%; }
      .landing-container { display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; max-width: 100%; }
      .desk-graphic { width: 180%; max-width: none; height: auto; position: relative; left: 50%; transform: translateX(-50%); display: block; object-fit: contain; object-position: center; }
      section.subscribe { min-height: 60vh; }

      .dot-nav { display: flex; right: 0.8rem; gap: 1.1rem; transform: translateY(-50%) scale(0.7); opacity: 0.9; }
      .dot-nav .dot { width: 9px; height: 9px; }
      .dot-nav .dot.active { transform: scale(1.85); }

      .turtle-container { height: 80px; margin-top: 1rem; }
      .turtle { width: 60px; height: 60px; }
      .turtle.animate { animation: walkAcrossWithDelay 20s linear infinite, walkSpriteBase 1.4s steps(2) infinite; }
    }
  </style>
</head>
<body>
  <a href="https://www.instagram.com/lepetit_desk/" target="_blank" rel="noopener noreferrer">
    <svg class="instagram-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/></svg>
  </a>

  <section class="landing">
    <div class="landing-container">
      <img src="static/desk.svg" alt="Le Petit Desk" class="desk-graphic" width="1600" height="1600" />
      <h1 class="title"><span>le</span><span>petit</span><span>desk</span></h1>
    </div>
  </section>

  <section class="mission">
    <div>
      <div class="event mission-title">our dorm turned studio</div>
      <p>we gather musicians in the most honest venue we knowâ€”our living room</p>
      <p>home to a petit desk with big sound</p>
      <p>no pressure, just music that matters</p>
      <p>made in good company</p>
      <div class="turtle-container"><div class="turtle"></div></div>
    </div>
  </section>

  <section class="upcoming">
    <div>
      <div class="event upcoming-title">fri, sep 19</div>
      <div class="event">le petit desk opening night</div>
    </div>
  </section>

  <section class="past">
    <div>
      <div class="event past-title">previously</div>
      <div class="event">nothing...yet</div>
    </div>
  </section>

  <section class="subscribe">
    <form id="subscribeForm" novalidate>
      <input type="email" id="emailInput" name="email" placeholder="your@email.com" required />
      <div class="subscribe-text">stay tuned to events at le petit desk</div>
      <div class="error-message" id="errorMessage">invalid email address</div>
      <div class="jam-with-us">want to jam with us?<br>have ideas for a concert?<br><br>let us know at <a href="mailto:lepetitdesk@gmail.com">lepetitdesk@gmail.com</a></div>
    </form>
  </section>

  <footer class="footer">
    <div>
      <div class="footer-title">le petit desk</div>
      <div class="footer-subtitle">brought to you by the team behind the <a href="https://goldenarmtheater.com" target="_blank" rel="noopener noreferrer">golden arm theater</a></div>
      <img class="footer-turtle" src="static/turtle_base/sprite_0.png" alt="turtle" width="32" height="32" />
    </div>
  </footer>

  <nav class="dot-nav">
    <div class="dot" data-section="landing"></div>
    <div class="dot" data-section="mission"></div>
    <div class="dot" data-section="upcoming"></div>
    <div class="dot" data-section="past"></div>
    <div class="dot" data-section="subscribe"></div>
  </nav>

  <script>
    gsap.registerPlugin(ScrollTrigger);
    
    const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbw3k-4-AcvT80aS8Bd9G6pWVrrAeIoPDhL7GmgPg_T93e-QNaMNDyBtkAICKkfgirVF_A/exec';
    const deskGraphic = document.querySelector('.desk-graphic');
    const titleContainer = document.querySelector('h1.title');
    const words = gsap.utils.toArray(".title span");
    const wordPositions = [{ x: 0.37, y: 0.4325 }, { x: 0.4625, y: 0.545 }, { x: 0.57, y: 0.595 }];

    function updateWordPositions() {
      const deskRect = deskGraphic.getBoundingClientRect();
      const titleRect = titleContainer.getBoundingClientRect();
      words.forEach((word, index) => {
        const pos = wordPositions[index];
        const targetX = deskRect.left + (deskRect.width * pos.x);
        const targetY = deskRect.top + (deskRect.height * pos.y);
        gsap.set(word, { left: targetX - titleRect.left, top: targetY - titleRect.top });
      });
    }

    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        updateWordPositions();
        window.dispatchEvent(new Event('debouncedResize'));
      }, 100);
    });

    const onPageReady = () => {
      updateWordPositions();
      window.dispatchEvent(new Event('pageReadyForBounds'));
    };
    deskGraphic.addEventListener('load', onPageReady);
    if (deskGraphic.complete) onPageReady();

    words.forEach((word, index) => {
      const rotations = [-4, 2, 0], delays = [0.3, 0.7, 1.1], bounceHeights = [25, 30, 28];
      gsap.timeline().to(word, { y: 0, opacity: 1, rotation: rotations[index], duration: 0.8, ease: "power3.in", delay: delays[index] })
        .to(word, { y: -bounceHeights[index], duration: 0.15, ease: "power2.out" }).to(word, { y: 0, duration: 0.25, ease: "power2.in" })
        .to(word, { y: -bounceHeights[index] * 0.6, duration: 0.12, ease: "power2.out" }).to(word, { y: 0, duration: 0.2, ease: "power2.in" })
        .to(word, { y: -bounceHeights[index] * 0.25, duration: 0.1, ease: "power2.out" }).to(word, { y: 0, duration: 0.15, ease: "power2.in" });
    });

    [".mission", ".upcoming", ".past", ".subscribe"].forEach(cls => {
      gsap.to(cls, { opacity: 1, y: 0, duration: 1.2, ease: "power3.out", scrollTrigger: { trigger: cls, start: "top 85%", toggleActions: "play none none none" }});
    });
    gsap.utils.toArray(".event").forEach((event, index) => {
      gsap.to(event, { opacity: 1, y: 0, duration: 1, ease: "power3.out", delay: index * 0.15, scrollTrigger: { trigger: event.closest('section'), start: "top 80%", toggleActions: "play none none none" }});
    });
    gsap.to(".mission p, .subscribe form", { opacity: 1, y: 0, duration: 1.2, ease: "power3.out", scrollTrigger: { trigger: ".mission", start: "top 85%", toggleActions: "play none none none" }});

    const emailInput = document.getElementById('emailInput'), errorMessage = document.getElementById('errorMessage'), subscribeForm = document.getElementById('subscribeForm');
    subscribeForm.addEventListener('submit', e => {
      e.preventDefault();
      const email = emailInput.value.trim();
      if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
        errorMessage.classList.add('show');
      } else {
        errorMessage.classList.remove('show');
        if (WEB_APP_URL) fetch(WEB_APP_URL, { method: 'POST', body: new URLSearchParams({ email }), mode: 'no-cors' });
        emailInput.value = '';
        document.querySelector('.subscribe-text').textContent = 'thanks! you\'re on the list';
      }
    });
    emailInput.addEventListener('input', () => errorMessage.classList.remove('show'));

    const dots = document.querySelectorAll('.dot-nav .dot'), sections = document.querySelectorAll('section');
    dots.forEach((dot, index) => {
      const section = sections[index];
      if (!section) return;
      ScrollTrigger.create({ trigger: section, start: "top center", end: "bottom center", onToggle: self => {
        if (self.isActive) { dots.forEach(d => d.classList.remove('active')); dot.classList.add('active'); }
      }});
      dot.addEventListener('click', () => section.scrollIntoView({ behavior: 'smooth', block: 'center' }));
    });

    const dotNav = document.querySelector('.dot-nav');
    let shrinkTimeout;
    ScrollTrigger.create({
      trigger: "body",
      onScrollStart: () => { if (window.matchMedia('(min-width: 769px)').matches) { clearTimeout(shrinkTimeout); dotNav.classList.add('expanded'); }},
      onScrollEnd: () => { if (window.matchMedia('(min-width: 769px)').matches) { shrinkTimeout = setTimeout(() => dotNav.classList.remove('expanded'), 1200); }}
    });
    dotNav.addEventListener('mouseenter', () => { if (window.matchMedia('(min-width: 769px)').matches) dotNav.classList.add('expanded'); });
    dotNav.addEventListener('mouseleave', () => { if (window.matchMedia('(min-width: 769px)').matches) dotNav.classList.remove('expanded'); });

    ScrollTrigger.create({ trigger: ".mission", start: "top 80%", onEnter: () => document.querySelector('.turtle')?.classList.add('animate'), once: true });
  </script>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getDatabase, ref, onValue, off, set } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyDcUEzJ33ZCM9U2PCkBgxREsAjBBC2InoE",
      authDomain: "le-petit-desk.firebaseapp.com",
      databaseURL: "https://le-petit-desk-default-rtdb.firebaseio.com",
      projectId: "le-petit-desk",
      storageBucket: "le-petit-desk.firebasestorage.app",
      messagingSenderId: "245188577687",
      appId: "1:245188577687:web:9d3b0bbbf56486f69e1cd2",
      measurementId: "G-MDXNW9DF26"
    };

    const app = initializeApp(firebaseConfig);
    const database = getDatabase(app);

    let activeTurtles = {}, isSessionActive = false, animationRunning = false;
    let currentRaceState = 'idle';
    const landingSection = document.querySelector('section.landing');
    let landingBounds = { width: 0, height: 0 };

    function updateBounds() {
      landingBounds.width = landingSection.offsetWidth;
      landingBounds.height = landingSection.offsetHeight;
    }
    
    window.addEventListener('pageReadyForBounds', updateBounds, { once: true });
    window.addEventListener('debouncedResize', updateBounds);
    updateBounds(); // Initial call to prevent race condition

    function updateAllTurtles() {
      if (!isSessionActive) return;
      
      if (currentRaceState === 'idle') {
        // Original wandering logic
        Object.values(activeTurtles).forEach(turtle => {
          if (!turtle.element.parentNode) return;

          const angleInRadians = turtle.rotation * (Math.PI / 180);
          turtle.x += turtle.speed * Math.sin(angleInRadians);
          turtle.y -= turtle.speed * Math.cos(angleInRadians);

          const turtleSize = 90;
          let hitBoundary = false;
          if (turtle.x < 0) { turtle.x = 0; hitBoundary = true; }
          if (turtle.x > landingBounds.width - turtleSize) { turtle.x = landingBounds.width - turtleSize; hitBoundary = true; }
          if (turtle.y < 0) { turtle.y = 0; hitBoundary = true; }
          if (turtle.y > landingBounds.height - turtleSize) { turtle.y = landingBounds.height - turtleSize; hitBoundary = true; }
          
          if (hitBoundary && !turtle.isRotating) {
            const centerX = landingBounds.width / 2;
            const centerY = landingBounds.height / 2;
            const angleToCenter = Math.atan2(centerX - turtle.x, -(centerY - turtle.y)) * (180 / Math.PI);
            const variance = (Math.random() - 0.5) * 90;
            smoothRotateToward(turtle, angleToCenter + variance);
          }

          gsap.set(turtle.element, { x: turtle.x, y: turtle.y });
          const nameElement = turtle.element.querySelector('.turtle-name');
          if (nameElement) {
            gsap.set(nameElement, { rotation: -turtle.rotation });
          }
        });
      } else if (currentRaceState === 'starting') {
        // During lineup and countdown, keep all turtles at 0 rotation
        Object.values(activeTurtles).forEach(turtle => {
          if (!turtle.element.parentNode) return;
          
          gsap.set(turtle.element, { x: turtle.x, y: turtle.y, rotation: 0 });
          const nameElement = turtle.element.querySelector('.turtle-name');
          if (nameElement) {
            gsap.set(nameElement, { rotation: 0 });
          }
        });
      } else if (currentRaceState === 'racing') {
        // Race logic
        Object.values(activeTurtles).forEach(turtle => {
          if (!turtle.element.parentNode) return;

          // Only move turtles that haven't finished
          if (!turtle.race.isFinished) {
            // Move turtle upward
            turtle.y -= turtle.race.speed;

            // Check for independent speed changes every 3-6 seconds
            const currentTime = Date.now();
            if (currentTime >= turtle.race.nextSpeedChange) {
              // 60% chance for speed increase, 40% chance for decrease
              if (Math.random() < 0.6) {
                // Speed increase: 0.03 to 0.08
                const increase = Math.random() * 0.05 + 0.03;
                turtle.race.speed += increase;
              } else {
                // Speed decrease: 0.03 to 0.08
                const decrease = Math.random() * 0.05 + 0.03;
                turtle.race.speed -= decrease;
              }
              
              // Clamp speed within reasonable bounds
              turtle.race.speed = Math.max(0.1, Math.min(1.0, turtle.race.speed));
              
              // Schedule next speed change in 3-6 seconds
              turtle.race.nextSpeedChange = currentTime + Math.random() * 3000 + 3000;
            }

            // Check if turtle reached finish line
            if (turtle.y <= 0) {
              turtle.y = 0;
              turtle.race.isFinished = true;
              // Pause walking animation
              const spriteElement = turtle.element.querySelector('.turtle-sprite');
              if (spriteElement) {
                spriteElement.style.animationPlayState = 'paused';
              }
            }
          }

          // Maintain 0-degree rotation during race (head pointing up) for all turtles
          gsap.set(turtle.element, { x: turtle.x, y: turtle.y, rotation: 0 });
          const nameElement = turtle.element.querySelector('.turtle-name');
          if (nameElement) {
            gsap.set(nameElement, { rotation: 0 }); // Keep name upright too
          }
        });
        
        // Check if all turtles have finished
        const allFinished = Object.values(activeTurtles).every(turtle => turtle.race.isFinished);
        if (allFinished && currentRaceState === 'racing') {
          // Update race state to finished
          set(ref(database, 'session/raceState'), 'finished');
        }
      } else if (currentRaceState === 'finished') {
        // Keep finished turtles stationary at 0 rotation until zen mode
        Object.values(activeTurtles).forEach(turtle => {
          if (!turtle.element.parentNode) return;
          
          gsap.set(turtle.element, { x: turtle.x, y: turtle.y, rotation: 0 });
          const nameElement = turtle.element.querySelector('.turtle-name');
          if (nameElement) {
            gsap.set(nameElement, { rotation: 0 });
          }
        });
      }
    }

    function smoothRotateToward(turtle, targetRotation) {
      if (turtle.isRotating) return;
      turtle.isRotating = true;
      gsap.to(turtle, {
        rotation: targetRotation,
        duration: 2.0 + Math.random() * 2.0, // A smooth, longer rotation
        ease: "sine.inOut",
        overwrite: 'auto',
        onUpdate: () => gsap.set(turtle.element, { rotation: turtle.rotation }),
        onComplete: () => turtle.isRotating = false
      });
    }

    // FIX 3: Implement specific wandering behavior
    function changeCourse(turtle) {
      if (!turtle || !isSessionActive) return;
      
      let rotationMagnitude;
      if (Math.random() < 0.5) {
        rotationMagnitude = Math.random() * 35 + 10; // 10-45 degrees
      } else {
        rotationMagnitude = Math.random() * 45 + 45; // 45-90 degrees
      }
      
      const rotationDirection = Math.random() < 0.5 ? 1 : -1;
      const newRotation = turtle.rotation + (rotationMagnitude * rotationDirection);
      smoothRotateToward(turtle, newRotation);
      
      const nextInterval = Math.random() * 5000 + 5000; // 5-10 seconds
      setTimeout(() => changeCourse(turtle), nextInterval);
    }

    function spawnTurtle(turtleId, turtleData) {
      if (activeTurtles[turtleId]) return;

      const turtleContainer = document.createElement('div');
      turtleContainer.className = `concert-turtle turtle-${turtleData.turtleType}`;
      const spriteDiv = document.createElement('div');
      spriteDiv.className = 'turtle-sprite';
      const nameSpan = document.createElement('span');
      nameSpan.className = 'turtle-name';
      nameSpan.textContent = turtleData.name;
      turtleContainer.append(spriteDiv, nameSpan);

      const turtleSize = 90, margin = 10;
      const initialX = Math.random() * (landingBounds.width - turtleSize - margin * 2) + margin;
      const initialY = Math.random() * (landingBounds.height - turtleSize - margin * 2) + margin;
      
      const turtleState = {
        element: turtleContainer, x: initialX, y: initialY,
        rotation: Math.random() * 360, speed: Math.random() * 0.2 + 0.3, isRotating: false,
        race: {
          isFinished: false,
          speed: 0,
          nextSpeedChange: 0
        }
      };

      gsap.set(turtleContainer, { x: initialX, y: initialY, rotation: turtleState.rotation, opacity: 1, scale: 1 });
      landingSection.appendChild(turtleContainer);
      changeCourse(turtleState);
      activeTurtles[turtleId] = turtleState;

      if (!animationRunning) {
        gsap.ticker.add(updateAllTurtles);
        animationRunning = true;
      }
    }

    function removeTurtle(turtleId) {
      const turtle = activeTurtles[turtleId];
      if (!turtle) return;
      gsap.killTweensOf([turtle.element, turtle]);
      gsap.to(turtle.element, {
        opacity: 0, scale: 0, duration: 1, ease: "back.in(1.7)",
        onComplete: () => turtle.element.remove()
      });
      delete activeTurtles[turtleId];
      if (Object.keys(activeTurtles).length === 0 && animationRunning) {
        gsap.ticker.remove(updateAllTurtles);
        animationRunning = false;
      }
    }

    function clearAllTurtles() {
      Object.values(activeTurtles).forEach(turtle => gsap.killTweensOf([turtle.element, turtle]));
      Object.keys(activeTurtles).forEach(removeTurtle);
    }

    function startTurtleListeners() {
      onValue(ref(database, 'turtles'), (snapshot) => {
        const turtles = snapshot.val() || {};
        Object.keys(activeTurtles).forEach(id => !turtles[id] && removeTurtle(id));
        Object.entries(turtles).forEach(([id, data]) => !activeTurtles[id] && spawnTurtle(id, data));
      });
    }

    function stopTurtleListeners() {
      off(ref(database, 'turtles'));
      clearAllTurtles();
    }

    // Race state handler
    function handleRaceStateChange(newState) {
      if (newState === 'starting') {
        initiateRace();
      } else if (newState === 'racing') {
        startRace();
      } else if (newState === 'idle') {
        enterZenMode();
      }
    }

    // Race state: starting - line up turtles and show countdown
    function initiateRace() {
      if (!isSessionActive) return;
      
      // Hide any existing countdown
      const existingCountdown = document.getElementById('raceCountdown');
      if (existingCountdown) existingCountdown.remove();
      
      const turtles = Object.values(activeTurtles);
      if (turtles.length === 0) return;
      
      // Position turtles at starting line - ensure all are visible and centered
      const startingY = landingBounds.height - 90;
      const turtleWidth = 90; // Width of each turtle
      const screenMargin = 20; // Minimum margin from screen edges
      
      let spacing, startingX;
      
      if (turtles.length === 1) {
        // Single turtle - center it
        startingX = (landingBounds.width - turtleWidth) / 2;
        spacing = 0;
      } else {
        // Multiple turtles - calculate optimal spacing and center the lineup
        const maxDesiredSpacing = 100; // Ideal spacing between turtle centers
        const idealLineupWidth = (turtles.length - 1) * maxDesiredSpacing + turtleWidth;
        
        if (idealLineupWidth <= landingBounds.width - (2 * screenMargin)) {
          // Use ideal spacing and center
          spacing = maxDesiredSpacing;
        } else {
          // Reduce spacing to fit on screen (may overlap if necessary)
          const availableWidthForSpacing = landingBounds.width - (2 * screenMargin) - turtleWidth;
          spacing = availableWidthForSpacing / (turtles.length - 1);
        }
        
        // Calculate actual lineup width and center it
        const actualLineupWidth = (turtles.length - 1) * spacing + turtleWidth;
        startingX = (landingBounds.width - actualLineupWidth) / 2;
      }
      
      turtles.forEach((turtle, index) => {
        gsap.killTweensOf([turtle.element, turtle]);
        turtle.isRotating = true; // Prevent wandering
        
        // Calculate position for this turtle
        const targetX = turtles.length === 1 ? startingX : startingX + (index * spacing);
        
        gsap.to(turtle, {
          x: targetX,
          y: startingY,
          rotation: 0, // Face upward
          duration: 2,
          ease: "power2.inOut",
          onUpdate: () => {
            gsap.set(turtle.element, { x: turtle.x, y: turtle.y, rotation: turtle.rotation });
            const nameElement = turtle.element.querySelector('.turtle-name');
            if (nameElement) {
              gsap.set(nameElement, { rotation: -turtle.rotation });
            }
          },
          onComplete: () => {
            turtle.isRotating = false;
          }
        });
      });
      
      // Show countdown
      setTimeout(() => showCountdown(), 1000);
    }

    // Show countdown animation
    function showCountdown() {
      const countdownDiv = document.createElement('div');
      countdownDiv.id = 'raceCountdown';
      countdownDiv.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: clamp(3rem, 8vw, 8rem);
        font-weight: bold;
        color: var(--accent);
        z-index: 20;
        text-shadow: 2px 2px 4px rgba(60, 38, 38, 0.8);
        pointer-events: none;
        opacity: 0;
      `;
      landingSection.appendChild(countdownDiv);
      
      let count = 3;
      const countdown = () => {
        countdownDiv.textContent = count;
        gsap.fromTo(countdownDiv, 
          { opacity: 0, scale: 0.5 },
          { opacity: 1, scale: 1, duration: 0.5, ease: "back.out(1.7)" }
        );
        
        setTimeout(() => {
          gsap.to(countdownDiv, { opacity: 0, scale: 1.5, duration: 0.5 });
        }, 500);
        
        count--;
        if (count > 0) {
          setTimeout(countdown, 1000);
        } else {
          setTimeout(() => countdownDiv.remove(), 1000);
        }
      };
      
      countdown();
    }

    // Race state: racing - assign speeds and start moving
    function startRace() {
      if (!isSessionActive) return;
      
      Object.values(activeTurtles).forEach(turtle => {
        // Assign tighter starting speed distribution for more equal footing
        turtle.race.speed = Math.random() * 0.1 + 0.3; // 0.3 to 0.4 (tight range)
        turtle.race.isFinished = false;
        
        // Set up independent speed change interval for each turtle
        turtle.race.nextSpeedChange = Date.now() + Math.random() * 3000 + 3000; // 3-6 seconds
        
        // Resume walking animation
        const spriteElement = turtle.element.querySelector('.turtle-sprite');
        if (spriteElement) {
          spriteElement.style.animationPlayState = 'running';
        }
      });
    }

    // Race state: idle (Zen Mode) - reset turtles to wandering
    function enterZenMode() {
      if (!isSessionActive) return;
      
      // Hide any countdown
      const existingCountdown = document.getElementById('raceCountdown');
      if (existingCountdown) existingCountdown.remove();
      
      Object.values(activeTurtles).forEach(turtle => {
        // Reset race properties
        turtle.race.isFinished = false;
        turtle.race.speed = 0;
        turtle.race.nextSpeedChange = 0;
        
        // Resume walking animation
        const spriteElement = turtle.element.querySelector('.turtle-sprite');
        if (spriteElement) {
          spriteElement.style.animationPlayState = 'running';
        }
        
        // Restart wandering behavior
        changeCourse(turtle);
      });
    }

    onValue(ref(database, 'session'), (snapshot) => {
      const session = snapshot.val();
      const sessionActive = session && session.isActive;
      const newRaceState = session ? (session.raceState || 'idle') : 'idle';
      
      if (sessionActive && !isSessionActive) {
        isSessionActive = true;
        startTurtleListeners();
      } else if (!sessionActive && isSessionActive) {
        isSessionActive = false;
        stopTurtleListeners();
      }
      
      if (newRaceState !== currentRaceState) {
        currentRaceState = newRaceState;
        handleRaceStateChange(newRaceState);
      }
    });
  </script>
</body>
</html>